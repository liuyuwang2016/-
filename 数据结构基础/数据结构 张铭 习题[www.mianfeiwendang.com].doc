{\rtf1\adeflang1025\ansi\ansicpg936\uc2\adeff0\deff0\stshfdbch13\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe2052{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f13\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}\'cb\'ce\'cc\'e5{\*\falt SimSun};}
{\f36\fnil\fcharset134\fprq2{\*\panose 00000000000000000000}@\'cb\'ce\'cc\'e5;}{\f38\froman\fcharset238\fprq2 Times New Roman CE;}{\f39\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f41\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f42\froman\fcharset162\fprq2 Times New Roman Tur;}{\f43\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f44\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f45\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f46\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f170\fnil\fcharset0\fprq2 SimSun Western{\*\falt SimSun};}{\f400\fnil\fcharset0\fprq2 @\'cb\'ce\'cc\'e5 Western;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\qj \li0\ri0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 
\fs21\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20 \ltrch\fcs0 \fs20\lang1024\langfe1024\loch\f0\hich\af0\dbch\af13\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}{
\s15\qc \li0\ri0\nowidctlpar\brdrb\brdrs\brdrw15\brsp20 \tqc\tx4153\tqr\tx8306\wrapdefault\aspalpha\aspnum\faauto\nosnaplinegrid\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs18\alang1025 \ltrch\fcs0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext15 \styrsid15098623 header;}{\s16\ql \li0\ri0\nowidctlpar
\tqc\tx4153\tqr\tx8306\wrapdefault\aspalpha\aspnum\faauto\nosnaplinegrid\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs18\alang1025 \ltrch\fcs0 \fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 
\sbasedon0 \snext16 \styrsid15098623 footer;}{\*\cs17 \additive \rtlch\fcs1 \af0 \ltrch\fcs0 \ul\cf2 \sbasedon10 \styrsid15098623 Hyperlink;}}{\*\latentstyles\lsdstimax156\lsdlockeddef0}{\*\pgptbl {\pgp\ipgp0\itap0\li0\ri0\sb0\sa0}}{\*\rsidtbl \rsid655764
\rsid1069012\rsid1462542\rsid2231290\rsid2847010\rsid2909350\rsid3152368\rsid3409549\rsid3869496\rsid4001084\rsid4419642\rsid4477090\rsid6493368\rsid7939098\rsid8944438\rsid9449096\rsid10236727\rsid10246904\rsid10505668\rsid10897542\rsid11282186
\rsid11941893\rsid12669821\rsid13312263\rsid13773176\rsid14707564\rsid15098623\rsid15222873\rsid15611782\rsid15665703\rsid15817367\rsid15866361\rsid16080730\rsid16195404\rsid16607898}{\*\generator Microsoft Word 11.0.0000;}{\info{\title 数据结构 张铭 习题}
{\subject 数据结构 张铭 习题}{\author \'ce\'c4\'b5\'b5\'cf\'c2\'d4\'d8\'cd\'f8}{\keywords \'ce\'c4\'b5\'b5\'cf\'c2\'d4\'d8}{\doccomm http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21}{\operator \'ce\'c4\'b5\'b5\'cf\'c2\'d4\'d8\'cd\'f8}{\creatim\yr2010\mo9\dy28\hr22\min9}{\revtim\yr2010\mo10\dy8\hr23\min4}{\version16}{\edmins12}
{\nofpages1}{\nofwords57}{\nofchars331}{\*\manager http://www.mianfeiwendang.com/}{\*\company http://www.mianfeiwendang.com/}{\*\category \'ce\'c4\'b5\'b5\'cf\'c2\'d4\'d8}{\nofcharsws387}{\vern24613}{\*\password 00000000}}{\*\xmlnstbl {\xmlns1 http://schema
s.microsoft.com/office/word/2003/wordml}{\xmlns2 urn:schemas-microsoft-com:office:smarttags}}\paperw11906\paperh16838\margl1134\margr1134\margt1134\margb1134\gutter0\ltrsect 
\deftab420\ftnbj\aenddoc\donotembedsysfont1\donotembedlingdata0\grfdocevents0\validatexml1\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors1\formshade\horzdoc\dgmargin\dghspace180\dgvspace156\dghorigin1134\dgvorigin1134\dghshow0
\dgvshow2\jcompress\lnongrid\viewkind1\viewscale85\splytwnine\ftnlytwnine\htmautsp\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule\nobrkwrptbl\snaptogridincell\allowfieldendsel\wrppunct\asianbrkrule\rsidroot3869496\newtblstyruls\nogrowautofit 
{\*\fchars 
!),.:\'3b?]\'7d\'a1\'a7\'a1\'a4\'a1\'a6\'a1\'a5\'a8\'44\'a1\'ac\'a1\'af\'a1\'b1\'a1\'ad\'a1\'c3\'a1\'a2\'a1\'a3\'a1\'a8\'a1\'a9\'a1\'b5\'a1\'b7\'a1\'b9\'a1\'bb\'a1\'bf\'a1\'b3\'a1\'bd\'a3\'a1\'a3\'a2\'a3\'a7\'a3\'a9\'a3\'ac\'a3\'ae\'a3\'ba\'a3\'bb\'a3\'bf\'a3\'dd\'a3\'e0\'a3\'fc\'a3\'fd\'a1\'ab\'a1\'e9
}{\*\lchars ([\'7b\'a1\'a4\'a1\'ae\'a1\'b0\'a1\'b4\'a1\'b6\'a1\'b8\'a1\'ba\'a1\'be\'a1\'b2\'a1\'bc\'a3\'a8\'a3\'ae\'a3\'db\'a3\'fb\'a1\'ea\'a3\'a4}\fet0{\*\wgrffmtfilter 013f}\ilfomacatclnup0{\*\template 
C:\\Documents and Settings\\Administrator\\\'d7\'c0\'c3\'e6\\doc.dot}{\*\ftnsep \ltrpar \pard\plain \ltrpar\qj \li0\ri0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 
\fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid14707564 \chftnsep 
\par }}{\*\ftnsepc \ltrpar \pard\plain \ltrpar\qj \li0\ri0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 
\fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid14707564 \chftnsepc 
\par }}{\*\aftnsep \ltrpar \pard\plain \ltrpar\qj \li0\ri0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 
\fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid14707564 \chftnsep 
\par }}{\*\aftnsepc \ltrpar \pard\plain \ltrpar\qj \li0\ri0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 
\fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid14707564 \chftnsepc 
\par }}\ltrpar \sectd \ltrsect\linex0\headery851\footery992\colsx425\endnhere\sectlinegrid312\sectspecifyl\sectrsid6493368\sftnbj {\headerr \ltrpar \pard\plain \ltrpar\s15\qc \li0\ri0\nowidctlpar\brdrb\brdrs\brdrw15\brsp20 
\tqc\tx4153\tqr\tx8306\wrapdefault\aspalpha\aspnum\faauto\nosnaplinegrid\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs18\alang1025 \ltrch\fcs0 \fs18\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 {\rtlch\fcs1 
\af0\afs24 \ltrch\fcs0 \b\f13\fs24\cf6\insrsid11941893 \loch\af13\hich\af13\dbch\f13 \'ce\'c4\'b5\'b5}{\rtlch\fcs1 \af0\afs24 \ltrch\fcs0 \b\f13\fs24\cf6\insrsid6493368\charrsid15098623 \loch\af13\hich\af13\dbch\f13 \'cf\'c2\'d4\'d8}{\rtlch\fcs1 
\af0\afs24 \ltrch\fcs0 \b\f13\fs24\cf6\insrsid6493368\charrsid15098623 \hich\af13\dbch\af13\loch\f13  }{\rtlch\fcs1 \af0\afs24 \ltrch\fcs0 \b\f13\fs24\cf6\insrsid6493368\charrsid15098623 \loch\af13\hich\af13\dbch\f13 \'c3\'e2\'b7\'d1\'ce\'c4\'b5\'b5
\'cf\'c2\'d4\'d8}{\rtlch\fcs1 \af0\afs24 \ltrch\fcs0 \b\fs24\cf6\loch\af13\insrsid6493368\charrsid15098623 
\par }{\field{\*\fldinst {\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \f13\fs32\cf6\insrsid11941893 \hich\af13\dbch\af13\loch\f13  HYPERLINK "}{\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \f13\fs32\cf6\insrsid11941893\charrsid11941893 \hich\af13\dbch\af13\loch\f13 
http://www.mianfeiwendang.com/}{\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \f13\fs32\cf6\insrsid11941893 \hich\af13\dbch\af13\loch\f13 " }{\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \fs32\cf6\loch\af13\insrsid8944438\charrsid13773176 {\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b02000000170000001e00000068007400740070003a002f002f007700770077002e00770065006e00640061006e0067007800690061007a00610069002e0063006f006d002f000000e0c9ea79f9bace118c8200aa004ba90b5400000068007400740070003a002f002f0077007700
77002e00770065006e00640061006e0067007800690061007a00610069002e0063006f006d002f000000795881f43b1d7f48af2c825dc485276300000000a5ab000000000000}}}{\fldrslt {\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \cs17\f13\fs32\ul\cf2\insrsid11941893\charrsid13773176 
\hich\af13\dbch\af13\loch\f13 http://www.mianfeiwendang.com/}}}\sectd \linex0\endnhere\sectdefaultcl\sftnbj {\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \fs32\cf6\loch\af13\insrsid6493368\charrsid15098623 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta \dbch .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta \dbch .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta \dbch .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang 
{\pntxta \dbch )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb \dbch (}
{\pntxta \dbch )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb \dbch (}{\pntxta \dbch )}}\pard\plain \ltrpar\qj \li0\ri0\sl180\slmult0
\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid6493368 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 {\rtlch\fcs1 \af0 
\ltrch\fcs0 \insrsid6493368 \loch\af0\hich\af0\dbch\f13 \'a1\'a1\'a1\'a1}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6493368 
\par }\pard \ltrpar\qc \li0\ri0\sl180\slmult0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid15817367 {\rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\insrsid6493368\charrsid6493368 \loch\af0\hich\af0\dbch\f13 \'b1\'be\'ce\'c4\'b5\'b5
\loch\af0\hich\af0\dbch\f13 \'cf\'c2\'d4\'d8\'d7\'d4}{\field\fldedit{\*\fldinst {\rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\cf11\insrsid16080730 \hich\af0\dbch\af13\loch\f0 HYPERLINK "http://www.mianfeiwendang.com/"}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\fs24\cf11\insrsid8944438\charrsid16080730 {\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b0200000003000000e0c9ea79f9bace118c8200aa004ba90b5400000068007400740070003a002f002f007700770077002e00770065006e00640061006e0067007800690061007a00610069002e0063006f006d002f000000795881f43b1d7f48af2c825dc485276300000000a5ab
0000000000}}}{\fldrslt {\rtlch\fcs1 \af0 \ltrch\fcs0 \cs17\fs24\ul\cf2\insrsid11941893 \loch\af0\hich\af0\dbch\f13 \'ce\'c4\'b5\'b5}{\rtlch\fcs1 \af0 \ltrch\fcs0 \cs17\fs24\ul\cf2\insrsid6493368\charrsid6493368 \loch\af0\hich\af0\dbch\f13 \'cf\'c2\'d4\'d8
\'cd\'f8}}}\sectd \linex0\headery851\footery992\colsx425\endnhere\sectlinegrid312\sectspecifyl\sectrsid6493368\sftnbj {\rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\insrsid16607898 \loch\af0\hich\af0\dbch\f13 \'a3\'ac\'c4\'da\'c8\'dd}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\fs24\insrsid6493368\charrsid6493368 \loch\af0\hich\af0\dbch\f13 \'bf\'c9\'c4\'dc\'b2\'bb\'cd\'ea\'d5\'fb\'a3\'ac\'c4\'fa\'bf\'c9\'d2\'d4\'b5\'e3\'bb\'f7\'d2\'d4\'cf\'c2\'cd\'f8\'d6\'b7\'bc\'cc\'d0\'f8\'d4\'c4\'b6\'c1\'bb\'f2\'cf\'c2\'d4\'d8}{\rtlch\fcs1 
\af0 \ltrch\fcs0 \fs24\insrsid6493368 \loch\af0\hich\af0\dbch\f13 \'a3\'ba}{\rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\insrsid6493368 
\par }\pard \ltrpar\qc \li0\ri0\sl180\slmult0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid3869496 {\field{\*\fldinst {\rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\insrsid3152368 \hich\af0\dbch\af13\loch\f0 
HYPERLINK "http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21"}{\rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\insrsid3152368\charrsid3152368 {\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b0200000003000000e0c9ea79f9bace118c8200aa004ba90b5400000068007400740070003a002f002f007700770077002e00770065006e00640061006e0067007800690061007a00610069002e0063006f006d002f000000795881f43b1d7f48af2c825dc485276300000000a5ab
0000}}}{\fldrslt {\rtlch\fcs1 \af0 \ltrch\fcs0 \cs17\fs24\ul\cf2\insrsid3869496\charrsid15866361 \hich\af0\dbch\af13\loch\f0 http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21}}}\sectd 
\linex0\headery851\footery992\colsx425\endnhere\sectlinegrid312\sectspecifyl\sectrsid6493368\sftnbj {\rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\insrsid6493368\charrsid6493368 
\par }\pard \ltrpar\qj \li0\ri0\sl180\slmult0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid6493368 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6493368 
\par }\pard \ltrpar\qc \li0\ri0\sl180\slmult0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid3869496 {\rtlch\fcs1 \af0\afs36 \ltrch\fcs0 \b\f13\fs36\insrsid3869496\charrsid15866361 \hich\af13\dbch\af13\loch\f13 数据结构 张铭 习题}
{\rtlch\fcs1 \af0\afs36 \ltrch\fcs0 \b\fs36\insrsid6493368\charrsid15866361 
\par }\pard \ltrpar\qj \li0\ri0\sl180\slmult0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid6493368 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6493368 
\par 
\par }\pard \ltrpar\qj \li0\ri0\sl360\slmult1\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid15866361 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f13\fs24\insrsid3869496\charrsid15866361 \hich\af13\dbch\af13\loch\f13  \par\par第一章概论 练习答案\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par1、解答： 【题意解析】\par\par本题指定了字符的顺序，所以不能按照ASCII字符顺序来排序。 【典型错误】\par\par1.不按照题目给出的字符顺序进行排序，而按照ASCII字符顺序。      2.没有给出排序结果\par\par3.认为顺序存储法比较节约空间，事实上由于字符空隙，顺序法并不节约空间；      4. 没有比较各种方法的优劣。 【数据结构】\par\par本题可以采用的存储结构有顺序（数组）和链表。\par\par1. 用二维数组array[NUMOFSTRING][MAX_LENGTH]，此题可定义const int\par\par[此处图片未下载成功]\par\par
优点:为紧凑存储结构，没有用于存储其他附加的信息，表示方法比较直观简单，代码实现十分容易。\par\par缺点:为每个但此都开辟了同样长度的空间,造成空间的浪费。      2. 用链表的结构存储，结点为结构               struct strings{\par\parchar string[MAX_LENGTH];                   strings *pNext;               }\par\par[此处图片未下载成功]\par\par
 \par\par优点:如果有后续工作如反复增删结点,效率很高.并且可以使用不连续的空间。      缺点:操作过程相对复杂,容易出错.而且排序过程需要从表头开始沿链索一个结点一个结点的比较搜索,相当费时。\par\par3. 索引存储\par\par是顺序存储的一种推广.使用一个字符串char data[500],其中将大小长度不等的数据结点(单词)顺序存储其中.令使用一个字符指针数组 char* index[n],存储一系列指针,每个指针指向存储区域的一个数据结点.\par\par排序时,直接对index中的地址值进行调换修改即可,而不用修改data中的任何内容。索引存储的优点是:由于单词长度不同,在存储时充分考虑了这个因素,可以节省空间,此外由于交换的不是单词本身而是http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21单词的地址,可以节省时间,从时空两方面得到了优化。 【排序结果】\par\parB899，B9，CRSI，CXY，PAB，PABC，5C，7\par\par2、解答：  【题意解析】\par\par本题没有指明这100个实数是否存在相等的情况，在这里，我们考虑存在多个最大值的情形（即100个实数可能有相等的），为了保存其位置，利用int pos[100]（因为有可能这100个实数都是相同的）来保存最大值的所有位置。 【典型错误】\par\par1. 用int类型的数组来保存这100个元素，没有注意题目中说的是“每个元素的值都是实数”。      2. 求最大值的时候代码如下：                   temp=0;\par\parfor(int i=0;i&lt;100;i  )                        if(Num[i]&gt;temp)                   temp=Num[i];\par\par评注：这样是错误的，例如：当Num[i]都是负数的时候。\par\par3. 未考虑可能存在多个最大值的情况，只保存了一个最大值的位置。 【数据结构】\par\par本题可以采用的存储结构有顺序（数组），链表和索引。本题最好使用数组存储结构。由于其他存储方法需要记录附加信息，使得空间有效利用不能够最大化。因此在空间上顺序存储是最优的。时间上，无论如何此题都要遍历所有的数，因此O(n)为可能的最优时间代价。加之此题的规模较小，因此使用大家最熟悉的顺序存储是较为优先的选择。 【算法描述】\par\par1. 由于最大值可能不止一个，甚至可能都是最大值，所以创建一个长度为100的整型数组pos[100]，用来记录最大值的位置。\par\par2. 初始情况，取这个数组的第一个位置为最大值所在的位置，存入变量position中。\par\par3. 假设有n（1≤n≤99）个最大值，那么pos[0, 1, 2, …, n-1]记录这些最大值的位置，且pos[n]=-1(-1是标记值，表明pos数组下标为n-1及以前的元素记录了最大值的位置)；假设有n（n=100）个最大值，那么pos[0, 1, 2, …, n-1http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21]记录这些最大值的位置，pos数组不再设-1的标记值。 具体源码如下：     # include &lt;iostream.h&gt;     void main(){\par\par//存放100个实数的数组\par\pardouble Num[100]={4543.9,4543.9,3,45,654.7,7,66,35,45,4,6,4543.9,5,46,54,6,43,5.980,34};           //记录最大值所在位置的数组        int pos[100];\par\par//初始设定数组的第1个元素为最大值        int position=0;\par\par//j指示位置数组pos的下标        int j=1;                                                      for(int i=1;i&lt;100;  i)\par\parif(Num[i]&gt;Num[position]) {\par\parposition=i;   //记下新的最大值的位置\par\parj=1;        //位置数组pos的下标恢复为1，下标为0的位置为position预留               }\par\parelse if(Num[i]== Num[position])                       pos[j  ]=i;  //记下重复最大值的位置        //位置数组pos的下标为0的位置为position预留        pos[0]=position;\par\par//-1为标识值，表示位置数组pos下标为0, 1, 2 (j-1)的位置存        //放的是最大值所在的位置        if(j&lt;100)               pos[j]=-1;\par\parcout&lt;&lt;&quot;最大值为：&quot;&lt;&lt; Num[position]&lt;&lt;endl;         cout&lt;&lt;&quot;最大值所在的位置为：&quot;&lt;&lt;endlhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21;         for(i=0; i&lt;100;   i){\par\parif(pos[i]==-1)        //-1是标识值                      break;\par\parcout&lt;&lt;&quot;第&quot;&lt;&lt;(pos[i] 1)&lt;&lt;&quot;个元素&quot;&lt;&lt;endl;        }     }\par\par \par\par第一章概论 练习答案\par\par本章练习题\par\par答案分页：  [1] [2]\par\par3、解答： 【逻辑结构】\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par逻辑结构由结点集合K和关系集合R来表示,以学生每周的课程表为例: 将每天的课程安排数据作为结点，一共引入7个结点，它们的名称依次为“星期一”，“\par\par星期二”，“星期三”，  ，“星期日”。全部结点组成结点集K。\par\par这些结点是复合类型，是一个结构体，包括当日课程的名称，时间和地点等。 这些结点两两之间有一个时间关系r,r={(“星期一“，“星期二”)，（“星期二”，“星期三”），（“星期三”，“星期四”），（“星期四”，“星期五”），（“星期五”，“星期六”），（“星期六”，“星期日”）。此集合中的6个元素描述了“时间先后”关系r。此外，还引入一个关系r*={“星期日”，“星期一”}，r*只含有一个元素，以表示星期日和下一周工作日的时间顺序。r和r*共同构成关系集R。其中r属于线性结构。R是一种环行的关系。 【存储结构】\par\par几种可行的存储方案比较     1.顺序表：见图一\par\par优点：逻辑清晰,查阅修改方便；缺点：需要占用整块的存储空间，对空间要求较大\par\par[此处图片未下载成功]\par\par
图一 顺序表存储课程表\par\par2.索引\par\par[此处图片未下载成功]\par\par
 \par\par图二 索引结构的课程表\par\par构造索引表，其中的指针分别指向每一天的课程\par\par优点：逻辑较清晰，不占http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21用整块的存储空间，缺点：算法较复杂，附加的空间代价较高（有索引表）     3．链表：链接的方法是可以采纳的一个方法,每个指针都指向逻辑关系中的紧邻后继,最后一个结点的指针指向首结点,构成一个循环链表.链表结构检索较繁琐. 【相关运算】\par\par常见的运算包括增、删、查、改运算，课程表的抽象数据类型可以定义如下： template&lt;class ELEM&gt;     class table\par\par//当程序使用此table模板时，应该在前面附加#include&lt;table&gt;     {\par\parpublic:\par\par//创建一张空课程表         table &lt; ELEM &gt; t;\par\par//创建一张天数为k的课程表，可默认k为7         table &lt; ELEM &gt; t(int k);\par\par//设置某天的课程(时间地点等),该结点的地址可由索引表找出         virtual void Setcourse( ELEM &amp; pday ) = 0;\par\par//把一个新的结点插入课程表，使该结点在表中位置是nPos 如果nPos = -1         //则插入到表尾部(同时地址加入索引表)\par\parvirtual void Addday( const ELEM * pday, int nPos = -1 ) = 0;           //删除课程表中某天(结点),释放该结点的空间,该结点的地址可由索引表找出         virtual void Removeday( ELEM &amp; pday ) = 0;             //清空整个课程表，成功返回true\par\parvirtual bool Clearall() = 0;\par\par//清空某天(结点)的所有内容，该结点的地址可由索引表找出,成功返回true         virtual bool Clearday( ELEM &amp; pday )= 0;\par\par//修改某天(结点)的课程(时间 地点等),该结点的地址可由索http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21引表找出         virtual void Changecourse( ELEM &amp; pday ) = 0;           //输出某天(结点)的课程内容,该结点的地址可由索引表找出         virtual void Printday( ELEM &amp; pday) = 0;         //输出所有课程内容（结点）\par\parvirtual void PrintList() = 0;           //根据系统时间查询当天课程\par\parvirtual void Current() = 0;           //统计课程总数\par\parvirtual int Number() = 0;             // 析构函数，清空课程表         ~table();     private:\par\parELEM * m_index; //索引表头指针\par\par[此处图片未下载成功]\par\par
}\par\par本章练习题\par\par \par\par[此处图片未下载成功]\par\par
本章练习题\par\par \par\par第二章线性表、栈和队列 练习\par\par \par\par本章练习\par\par答案分页：答案分页：上一章\par\par下一章\par\par[此处图片未下载成功]\par\par
 \par\par[1] [2]  [1] [2]\par\par1、（教材习题2.1）给出一个算法，求单链表X中，内容为a的结点地址。  2、（教材习题2.5）给出一个算法，求出循环表中结点的个数。\par\par3、（教材习题2.8）编号为1，2，3，4的四辆列车，顺序开进一个栈式结构的站台；问开出车站的顺序有多少种可能，请具体写出来。\par\par4、（教材习题2.10）环状的队列，写出计算队列元素个数的程序。\par\par5、（教材习题2.19）现有4个元素作为双端队列的输入，问可以得到多少种不同的排列？  参考答案\par\par \par\par第二章线性表、栈和队列 练习答案\par\par上一章   下一章\par\par[此http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par1、解答： 【题意解析】\par\par本题没有指明是否存在多个内容为a的地址，在这里，我们考虑存在多个结点内容为a的情形。 【典型错误】\par\par没有考虑内容为a的地址可能有多个。 【数据结构】\par\par由于链表中内容为a的结点数目不确定，可以选择用一个新链表来存放找到的结点地址。这样的存储结构 优于定长数组。\par\par本题中涉及到两个链表：原链表ListNode和用于存储结点地址的新链表ListAddress。 【算法描述】\par\par1.       设pfirst和qfirst分别是这两个链表的头指针，p，q为指针变量。     2.       p从链表X的表头开始向后移动，每当遇到原链表中内容为a的结点，就在新链表中增\par\par加一个结点记录下其地址（用指针指向该结点来进行记录），如此循环直到链表X的表尾。\par\parstruct ListNode        //链表结点定义     {\par\parELEM data;        //数据类型为ELEM\par\parListNode* plink;    //指向后继结点的指针     };\par\parListNode* pfirst;       //pfirst指向原链表第一个结点     ListNode* p;          //原链表的指针变量，程序运行时可对其所指结点进行\par\par各种运算\par\parp=pfirst;              //指向头指针\par\parStruct ListAddress      //用于存放地址的新链表     {\par\parListNode * address;  //存放地址,类型为指向链表X的结点的指针        ListAddress* qlink;  //新链表的指针变量     };\par\parListAddress* qfirst;     //qfirst指向新链表第一个结点     qfirst-&gt;qlink=NUhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21LL;    //空表\par\parListAddress* q=qfirst;   //指向头指针\par\parvoid find(ELEM a)      //用于查找内容为a的结点，并记录其地址，参数为待查数据a     {\par\parwhile(p!=NULL)     //未到达链表尾结点        {\par\parif(p-&gt;data= =a)   //找到符合条件的结点，插入新链表           {\par\parq-&gt;qlink=new ListAddress;    //创建内存空间\par\parq-&gt;qlink-&gt;address=p;         //存储指向该结点的指针              q=q-&gt;qlink;                 //指针向后移              q-&gt;qlink=NULL;           }\par\parp=p-&gt;plink;       //指针后移继续查找        }\par\par}\par\par2、解答：  【算法描述】\par\par判断已经遍历整个循环表的方法：使用一个指针变量link从链表首元素向后遍历整个链表，直到link==first时，说明该结点即尾结点。设空表时结点数count为0（此时first-&gt;link=first），每经过一个结点count加1，直到到达尾结点。     struct ListNode     {\par\parELEM data;        ListNode* link;     };\par\parint Length (ListNode* first)      //first为循环表的头指针     {\par\parListNode* p;          p=first;\par\parint count=0;          //用于记录结点数,空链表时结点数为0          while(p-&gt;link!=first)   //未到达尾结点          {\par\parp=p-&gt;link;       http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21  //指针向后移\par\parcount  ;          //结点数加1          }\par\parreturn count;      }\par\par3、解答： 有14种可能： 【思路】\par\par先进站的车可以先开，也可以后开。只有一种情况不可能：编号大的车开出后，比其编号小的车反序开出。也即编号大的车开出后，编号比其小的车只能由大到小依次开出（中间可以插入编号更大的车，但此车后面的编号小的车也要遵守此规则）。例如312的开出顺序是不可能的。对所有车进行全排列共有24种出法。但4开头的只能有一种：4321。所以少了3的全排列-1=5种。三开头的时候，必须先2后1开出，先1后2时4的位置有三种：\par\par3124、3142、3412，所以少了三种。1或2开头的时候，后面的车如果是4，则最后两辆必须是3、2或3、1。所以又少了1423、2413两种。总共少了5 3 2=10种，有24-10=14种开出法。     下面用 表示进站，-表示出站：     1234：1   1-  2   2-  3   3-  4   4-     1243：1   1-  2   2-  3   4   4-  3-     1324：1   1-  2   3   3-  2-  4   4-     1342：1   1-  2   3   3-  4   4-  2-     1432：1   1-  2   3   4   4-  3-  2-     2134：1   2   2-  1-  3   3-  4   4-     2143：1   2   2-  1-  3   4   4-  3-     2314：1   2   2-  3   3-  1-  4   4-     2341：1   2   2-  3   3-  4   4-  1-     2431：1   2   2-  3   4   4-  3-  1-     3214：1   2   3   3C  2C  1C  4   4 -     3241：1   2   3   3-  2-  4   4-  1-     3421：1   2http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21   3   3-  4   4-  2-  1-     4321：1   2   3   4   4-  3-  2-  1-\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第二章线性表、栈和队列 练习答案\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par4、解答： 【算法描述】    对于顺序队列\par\parint Queue::length_of_queue()\par\par{\par\parif(IsEmpty()) return 0;\par\parif(front&lt;=rear)return rear-front;               else return maxsize rear-front;      }\par\par对于链式队列\par\parint Queue::length_of_queue()      {\par\parif(IsEmpty()) return 0;             int total=0;\par\parfor(ListPtr temp=front;temp!=rear;temp=temp-&gt;link)total  ;             return total;      }\par\par5、解答：\par\par双端队列可以在队列的两端进行插入和删除操作，既可在队尾进行插入/删除，又可在队头进行插入/删除。但第一个元素从左或右入队没有区别，以后每个元素都有两种入队方式。即有2^3=8种方法。不妨设元素为a,b,c,d,各种排列如下：     第一次放入a：     a\par\par第二次放入b：     ab ba\par\par第三次放入c：     cab abc cba bac     第四次放入d：\par\pardcab cabd dabc abcd dcba cbad dbac bacdhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21        故共有8种。\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第三章字符串 练习\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题3.1）设有字符串变量String A ＝''，B＝'MULE'，C＝'OLD'，D＝'MY' ; 请计算下列表达式     (a) A B     (b) B A     (c) D C B     (d) B.substr(3，2)     (e) C.substr(1，1)\par\par(f) A.str1ength()     (g) D.str1ength()     (h) B.Find('L')     (i) C.FindLast('D')     (j) D.insert(B,2)     (k) B.insert(B,1)     (1) B.remove(2，2)     (m) B.remove(0，5)\par\par2、（教材习题3.2）计算下列字符串P的特征向量N[i]\par\par(a) 'A B C D E F G H'      (b) 'I I I I I I I I'      (c) 'B A B B A B A B'     注意串内字符间有空格隔开\par\par3、设计算法用顺序结构存储的串s和串t的一个最长公共子串。\par\par4、编写程序，统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符为A-Z这26个字母和0-9这10个数字）。\par\par参考答案\par\par \par\par第三章字符串 练习答案\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par1、解答： 【典型错误】\par\par1. 在计算字符串长度时容易把结束符算在内，比如：   http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21  A.strlength()=2     D.strlength()=3\par\par2．在计算子串的时候容易加入结束符，比如：     B.substr(3,2)=&quot;E\n&quot;\par\par3．字符串的下标从从1开始，正确的是从0开始。\par\par4.  D.insert(B,2) 应当在D字符串的第2个下标处插入B字符串，而不是插入’B’字符，\par\parB.remove(2,2) 是从B字符串的第2个下标处开始删除2个字符， 这两个表达式的计算容易出错 【计算结果】\par\par(a)      A B=&quot;MULE&quot;     (b)      B A=&quot;MULE&quot;\par\par(c)      D C B=&quot;MYOLDMULE&quot;     (d)      B.substr(3,2)=&quot;E&quot;\par\par
(e)      C.substr(1,1)=&quot;L&quot;     (f)       A.strlength()=0     (g)      D.strlength()=2     (h)      B.Find('L')=2     (i)        C.FindLast('D')=2\par\par(j)        D.insert(B,2)=&quot;MYMULE&quot;     (k)      B.insert(B,1)=&quot;MMULEULE&quot;     (l)        B.remove(2,2)=&quot;MU&quot;\par\par(m)    B.remove(0,5)=&quot;&quot; （空串）\par\par2、解答：\par\par(a)  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0     (b)  0 0 1 2 3 4 5 6 7 8 9 10 11 12 13     (c)  0 0 0 0 1 2 1 2 3 4 5 6 3 4 5\par\par[此处图片未下载成功]\par\par
 \par\par本章练http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21习题\par\par答案分页：  [1] [2]\par\par \par\par第三章字符串 练习答案\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par3、解答： 【算法描述】\par\par串s用i指针(1&lt;=i&lt;=s.len)。t串用j指针(1&lt;=j&lt;=t.len)。算法思想是对每个i(1&lt;=i&lt;=s.len，即程序中第一个while循环)，来求从i开始的连续字符串与从j(1&lt;=j&lt;=t.len，即程序中第二个WHILE循环)开始的连续字符串的最大匹配。程序中第三个(即最内层)的while循环，是当s中某字符(s[i])与t中某字符(t[j])相等时，求出局部公共子串。若该子串长度大于已求出的最长公共子串(初始为0)，则最长公共子串的长度要修改。\par\parvoid  maxcomstr(orderstring *s,*t; int index, length) {\par\parint i,j,k,length1,con;     index=0;length=0;i=1;     while (i&lt;=s.len)     {\par\parj=1;\par\parwhile(j&lt;=t.len)\par\par
{\par\parif (s[i]= =t[j])          {\par\park=1;length1=1;con=1;             while(con)\par\parif(i k&lt;=s.len &amp;&amp; j k&lt;=t.len &amp;&amp; s[i k]==t[j k])                  //如果在s和t的长度内，对应字符相等，则指针k 后移                 { length1=length1 1;k=k 1; }\par\parelse con=0; //s和t对应字符不等时置标记退出             if(length1&gt;length) {http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21 index=i;  length=length1; }             j =k;   //在t串中，从第j k字符再与s[i]比较          }\par\parelse j  ; //t串取下一字符        }\par\pari  ; //s串指针i后移      }  }\par\par4、解答： 【算法描述】\par\par由于字母共26个，加上数字符号10个共36个，所以设一长36的整型数组，前10个分量存放数字字符出现的次数，余下存放字母出现的次数。从字符串中读出数字字符时，字符的ASCII代码值减去数字字符 ‘0’的ASCII代码值，得出其数值(0..9)，字母的ASCII代码值减去字符‘A’的ASCII代码值加上10，存入其数组的对应下标分量中。遇其它符号不作处理，直至输入字符串结束。 void Count()\par\par//统计输入字符串中数字字符和字母字符的个数。 {\par\parint i，num[36]；     char ch；\par\parfor(i＝0；i&lt;36；i  )num[i]＝0；// 初始化\par\parwhile((ch＝getchar())!=‘#’)  //‘#’表示输入字符串结束。     if(‘0’&lt;=ch&lt;=‘9’){i=ch－48;num[i]  ；}        // 数字字符      else if(‘A’&lt;=ch&lt;=‘Z’){i=ch-65 10;num[i]  ；}// 字母字符        for(i=0；i&lt;10；i  )  // 输出数字字符的个数\par\parprintf(“数字％d的个数＝％d\n”，i，num[i])；    for(i＝10；i&lt;36；i  )// 求出字母字符的个数\par\parprintf(“字母字符％c的个数＝％d\n”，i＋55，num[i])； }\par\par \par\par[此处图片未下载成功]\par\par
本章练习题\par\par
答案分页：  [1] [2]\par\par \par\par第四章检索 练习\par\par上一章   下一章\pahttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21r\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题4.5）写一个递归函数计算二叉树叶结点的个数。\par\par2、（教材习题4.11）写出在中序穿线二叉树里找指定结点在后序下的前驱的算法。\par\par3、（教材习题4.15）证明二叉搜索树结点的中序序列就是二叉搜索树结点按关键码值排序的序列。 4、（教材习题4.19）递归程序smallcount,传入二叉搜索树BST的根和至K,返回值小于或等于K的结点个数。相应写出非递归函数。\par\par参考答案\par\par \par\par第四章二叉树 练习答案\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par1、解答： 【算法描述】\par\par统计二叉树叶结点的个数的递归函数如下：\par\partemplate &lt;class T&gt; int BinaryTree&lt;T&gt;::leafnumber( BinaryTreeNode&lt;T&gt; * root) {\par\parif (root==NULL) return 0; //为空子树，无叶子结点     if (root-&gt;isLeaf()) return 1; //为叶子结点     //返回统计左、右子树中的叶结点数\par\parreturn leafnumber(root-&gt;leftchild()) leafnumber(root-&gt;rightchild()); }\par\par2、解答：  【题意解析】\par\par在后序排列的二叉树中，如果给定节点有右子树，则给定节点的前驱是其右子树的根节点。否则，如果给定节点的有左子树，则其前驱是其左子树的根结点。\par\par如果给定的节点既没有右子树，也没有左子树。即，给定的节点是叶节点。则可以利用穿线树的结构很容易地找到给定结点在中序周游下的前驱x。根据中序周游的特点，如果给定结点有前驱x，给定节点是x的右子树\par\par
在中序周游http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21下的第一个结点，则其也是x的右子树在后序周游下的第一个结点。所以，如果x有左子树，则其根结点就是x的左子树在后序周游下的最后一个结点，也就是给定结点在后序周游下的前驱。\par\par如果x没有左子树，则找到x在中序周游下的前驱x'，可以判定，给定节点也是x'的右子树在后序周游下的第一个结点，所以x'如果有左子树，则其根结点是给定结点在后序周游下的前驱。如果没有，则依照这个方法继续寻找x'的在中序周游下的前驱。直到找出一个有左子树的结点为止。 【算法描述】\par\parThreadBinaryTreeNode *FindPreInsorder( ThreadBinaryTreeNode *pointer) { //在中序穿线二叉树中找指定结点在后序下的前驱     ThreadBinaryTreeNode * temppointer = NULL;     //指定结点有右子女     if (pointer -&gt; rTag == 0)         return pointer -&gt; rightchild();     else\par\partemppointer = pointer;     while (temppointer -&gt; lTag == 1)         //结点在中序下的前驱\par\partemppointer = temppointer -&gt; leftchild();     temppointer = temppointer -&gt; leftchild();     return temppointer;\par\par[此处图片未下载成功]\par\par
}\par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第四章二叉树 练习答案\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par3、解答： 【证明】\par\par本题可以有多种解法，反证、归纳等等，下面给出归纳法证明。     设二叉搜http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21索树共有n个结点。 (1) 当N=0，即二叉树为空时显然成立； (2) 当N=1,即二叉树只有一个结点时显然成立；\par\par(3) 假设当N≤K，即二叉树有小于或等于K个结点时，这些个结点的中序排列就是它们按关键码值排序的序列。则对有K 1个结点的二叉搜索树，其根结点的左右子树的结点个数均小于或等于K，所以其左右子树结点的中序排列都是这些结点按关键码值排序的序列。整棵树的中序序列为A={左子树中序序列}{根}{右子树中序序列}。根据二叉搜索树的性质，根结点的左子树中所有结点的关键码值都小于根结点的关键码值，而右子树中所有结点的关键码都大于根结点的关键码值。序列A仍是按关键码排序的序列；\par\par由(1)、(2)、(3)可知，二叉搜索树的结点的中序排列就是二叉搜索树结点按关键码值排序的序列。\par\par
4、解答：  【题意解析】\par\par采取中序周游该二叉树，但为了保证尽可能少的访问结点，可通过比较结点值与k值的大小来判断周游的路径。 【算法描述】 方法一：递归算法\par\partemplate&lt;class T&gt; int smallcount(BinaryTreeNode&lt;T&gt; * root,T k) {     if (root==NULL)         return 0;\par\parelse if (k&gt;=root-&gt;value())\par\parreturn (1 smallcount(root-&gt;leftchild(),k) smallcount(root-&gt;rightchild(),k));     else\par\parreturn smallcount(root-&gt;leftchild(),k);\par\par//若k小于结点值，只需返回其左子树的值即可，减少访问结点的个数 }\par\par方法二：非递归算法：\par\partemplate&lt;class T&gt; int smallcountWithoutRecursion(BinaryTreeNode&lt;T&gt; * root,T k) {     int n=0; //计数器\http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21par\parusing std::stack; //使用STL中的stack\par\parstack&lt;BinaryTreeNode&lt;T&gt; * &gt; aStack; //建立一个栈     BinaryTreeNode&lt;T&gt; * pointer=root;     while (!aStack.empty() || pointer) {         if (pointer) {\par\paraStack.push(pointer); //当前结点入栈             pointer=pointer-&gt;leftchild();         }         else {\par\parpointer=aStack.top(); //返回栈顶             if (pointer-&gt;value()&lt;=k)\par\parn  ; //若满足&lt;=k，计数器加一             else\par\parbreak; //若不满足，因为右侧的值必定都不满足，故可跳出循环             pointer=pointer-&gt;rightchild();             aStack.pop(); //栈顶元素退栈         }     }\par\parreturn n; //返回计数器的值 }\par\par \par\par[此处图片未下载成功]\par\par
本章练习题\par\par答案分页：  [1] [2]\par\par
 \par\par第五章树 练习\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题5.3）将教材中图5.22（下图）的二叉树转换为对应的森林，分别按照先根次序和后根次序列出其结点。\par\par[此处图片未下载成功]\par\par
 \par\par2、（教材习题5.5）编写一个算法来判断在不考虑子树顺序的前提下是否相等。尽可能提高算法效率，并分析算法的运行时间。\par\par3、（教材习题5.8）分析http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21&quot;子结点表&quot;表示法和&quot;左子结点/有兄弟结点&quot;表示法的结构性开销比率。相比之下，它们各自的空间效率如何？\par\par4、（教材习题5.12）使用数学归纳法证明非空满K叉树的叶结点数目为(K-1)*n 1,其中n为分支结点数目。 参考答案\par\par第五章树 练习答案\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par1、解答：      对应的森林为\par\par答案分页：  [1] [2]\par\par
[此处图片未下载成功]\par\par
[此处图片未下载成功]\par\par
[此处图片未下载成功]\par\par
 \par\par先根周游：ABECFDGHIJKL     后根周游：EBFCDAIJKHGL\par\par2、解答：  【题意解析】\par\par在题中意义下，两棵树相等的充要条件是：其根结点相等，并且根结点对应的子树集合相等。\par\par[此处图片未下载成功]\par\par
 \par\par可采用递归思想去比较两棵树, 本题的难点在于比较不考虑次序的两个子树集合。 【典型错误】\par\par错误解法1：对子树的根结点进行排序,然后按照排好的序依次比较对应位置的子树。 问题：有可能两棵子树的根的值相等，但是下面的部分却不相等，此时比较会出出错。\par\par错误解法2：对 中的每一棵子树，都试图从 中找是否有相等的子树，若所有的都能找到则两个集合相等。 问题：\par\par[此处图片未下载成功]\par\par
【算法描述】\par\par比较两个子树集合可采用如下的算法: //若两个集合的大小不相等,则不可能相等. if (sizeof( ))!=sizeof( ))     return false;\par\par//下面的判断基于两个集合相等. for each {     find=false;     for each          if {\par\par \par\par
delete from //防止重复比较             findhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21=true;             break;         }     }\par\parif (!find) return false; }\par\par注意中间有一句delete from , 可防止当一个集合中因有两个元素相等时带来的重复比较错误. 一种实现上述算法的代码如下:\par\par// 判断两棵树是否相等（不考虑子结点顺序），rt1 和 rt2 分别为的两棵树的树根 // 两棵树相等的充要条件是：其根结点相等，并且根结点对应的子树集合相等 bool SpecialEqualTree(TreeNode *rt1, TreeNode *rt2) {\par\par// 先判断根结点，若一个结点为NULL而另一个不为NULL,则返回为false //若根结点不同，也直接返回 false     if ((rt1==NULL)&amp;&amp;(rt2==NULL))         return true;\par\parif (((rt1==NULL)&amp;&amp;(rt2!=NULL)) || ((rt1!=NULL)&amp;&amp;(rt2==NULL)) )         return false;\par\parif (rt1-&gt;data != rt2-&gt;data)         return false;\par\parif (rt1.IsLeaf() &amp;&amp; rt2.IsLeaf())         return true;     using namespace std;\par\parlist&lt;TreeNode *&gt; chs1, chs2; // 分别存储两棵树的孩子列表     TreeNode *ch1, *ch2;\par\par// 先将两棵树的所有子结点存入列表中\par\parfor (ch1 = rt1-&gt;LeftMostChild(); ch1 != NULL; ch1 = ch1-&gt;RightSibling())         chs1.push_back(ch1);\par\parfor (ch2 = rt2-&gt;Lefhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21tMostChild(); ch2 != NULL; ch2 = ch2-&gt;RightSibling())         chs2.push_back(ch2);\par\par// 如果孩子个数不等，则直接返回 false     if (chs1.size() != chs2.size())         return false;\par\parlist&lt;TreeNode *&gt;::iterator it1, it2; // 子节点列表的迭代器     // 将 rt1 的每棵子树和 rt2 的每棵子树进行比较，并判断     for (it1 = chs1.begin(); it1 != chs1.end(); it1  ) {         for (it2 = chs2.begin(); it2 != chs2.end(); it2  )\par\par// 如果从 rt2 的子树中找到了和 *it1 匹配的子树 *it2，就将 *it2          // 从 rt2 的孩子列表中删除，以避免以后重复判断，并终止后续比较         if (SpecialEqualTree(*it1, *it2)) {             chs2.erase(it2);             break;         }\par\par// 如果没有找到任何与 *it1 匹配的子树，就返回 false\par\par
if (it2 == chs2.end())             return false;     }\par\par// 如果 rt1 的每棵子树都在 rt2 的子树中找到了对应的匹配，就返回 true     return true; }\par\par复杂度分析:\par\par上述算法最坏的情况下每个子树对都需要比较一次,即任意 都需要比较一次，复杂度为O(mn)。\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第五章树 练习答案\par\par \par\par上一章http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par3、解答： 【解答】\par\par假设数据域的长度为x，指针域的长度为y。 (1) 对于&quot;子结点&quot;表示法：\par\par假设共有n个结点，那么所有链表的结点数总和为n-1 (因为除根结点外每个结点都有一个父结点，所以除根结点外指向每个结点的指针都会在链表中出现一次)。\par\par那么数组的空间为 (x 2y)n，链表的空间为(n-1)2y，结构性开销为所有指针域的开销，开销为 (n-1)2y 2yn，比率为((n-1)2y 2yn)/(x 2y)n (n-1)2y，当n较大时，(n-1)/n －&gt;1，所以上式近似为 4y/(x 4y)=1/(1 x/4y)。 (2) 对于左子结点/右兄弟结点法：\par\par设为n个结点，结构性开销为3yn，总的空间为 (x 3y)n，所以结构性开销比率为3yn/(xn 3yn) =1/(1 x/3y)。 (3) 可以看出 1/(1 x/3y) &lt; 1/(1 x/4y)，所以左子结点/右兄弟结点法效率更高。\par\par4、解答：  【证明】\par\par1． 当n=0时，只有一个根结点，此时叶结点数目为1，而(K-1)n 1也为1 n=1时，(K-1)n 1=K, 这是只有一个分支结点的情况，结果正确；\par\par2．假设n=m ( m&gt;=1, m为自然数)时叶结点数目为 （K-1）m 1，则n=m 1时，相当于把n=m时的K叉树里的一个叶结点扩展为分支结点，叶结点增加K-1个\par\par故n=m 1时，叶结点数目为(K-1)m 1 K-1=(m 1)K-m=(m 1)K-(m 1) 1=(K-1)(m 1) 1=(K-1)n 1 即n=m 1时此公式仍然成立。 综1、2所述，该公式成立，证毕。\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par
答案分页：  [1] [2]\par\par \par\par第六章图 练习\par\par \par\phttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21ar上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题6.7）有向图G=（V，E）的转置是图GT=(V，ET)，其中边&lt;u，w&gt;∈ET当且仅当&lt;w，u&gt;∈E，即GT就是G的所有边反向所组成的图。请按照相邻矩阵和邻接表两种表示法写出从G计算GT的有效算法，并确定算法的时间代价。\par\par2、（教材习题6.11）证明： 如果图G所有边的权值均不相等，则它只存在一棵最小支撑树（MST）。 3、（教材习题6.13）写出一个找图（有向图或无向图）的所有连通分量（对于有向图则是强连通分量）的算法。提示：第一个连通分量的所有顶点使用第一分量的标记，第二个连通分量的所有顶点使用第二分量的标记，依此类推。\par\par4、（教材习题6.17）什么样的有向无环图（DAG）具有唯一的拓扑序列？。\par\par5、（教材习题6.21）只要图中不存在权值为负数的边，Dijkstra算法就可以使用。如果一个图存在权值为负数的边，Dijkstra算法是否继续可用？如果你认为Dijkstra算法不可用，你是否有办法改进Dijkstra算法使其可用？证明你的结论，如果你改进了Dijkstra算法，也请证明你所做改进的正确性。\par\par参考答案\par\par \par\par第六章图 练习答案\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par1、解答： class Graph { public:\par\parint VerticesNum();        int EdgesNum();\par\parEdge FirstEdge(int oneVertex);        Edge NextEdge(Edge preEdge);\par\parbool setEdge(int fromVertex, int toVertex, int weight);\par\par
bool delEdge(int fromVertex, ihttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21nt toVertex); };\par\par// 邻接矩阵表示法\par\parclass Graphm:public Graph { public：\par\parGraphm* Transpose(); }\par\parGraphm* Graphm::Transpose() {\par\parint numVertex = VerticesNum(); Graphm* GT = new Graphm(numVertex); Edge tempE;\par\parfor (int i = 0；i &lt; numVertex; i  ) {        tempE = FirstEdge(i);        while (tempE.to != -1) {\par\parGT-&gt;setEdge(tempE.to, i, tempE.weight);               tempE = NextEdge(tempE);\par\par} }\par\parreturn GT; }\par\par此算法的时间复杂度为O(N2)，N为顶点数目 // 邻接表表示法\par\parClass Graphl: public Graph { public:\par\parGraphl* Transpose()； }\par\parGraphl* Graphl::Transpose() {\par\parint numVertex = VerticesNum(); Graphl* GT = new Graphl(numVertex);\par\par
Edge tempE;\par\parLink&lt;listUnit&gt; *temp;\par\parfor (int i = numVertex-1；i &gt;= 0; i--) {\par\partemp = graList[i].head;\par\parwhile (temp-&gt;next != NULL) {\par\parGT-&gt;setEdge(temp-&gt;next-&gt;element.vertex, i,temp-&gt;next-&gt;elemenhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21t.weight);\par\partemp = temp-&gt;next;\par\par} }\par\parreturn GT; }\par\par此算法的时间复杂度为O(M)，M为边的数目\par\par2、证明：\par\parMST的求解的过程是把一个个顶点插入，并且同时把所有和已经插入顶点的带权的边也插到最小堆里面的过程，然后，根据堆中的最小的权的边指向的结点来确定应该下一步插入那一个结点。因而，如果一个图中所有边的权都是不一样的，那么，堆中任何时候的最小的值只有一个，那么也就不会存在同时有两种选择的可能。也就是说，MST的建立是一个唯一的过程，不会因为起点的不同而有什么变化。因此对于一个确定的所有的边权都不一样的图，它的MST是唯一确定的，无论从哪一个结点开始构造MST，对于一个图中有的边的权值相同的情况，构造出来的MST有可能是唯一的，也有可能不存在几种情况。\par\par \par\par[此处图片未下载成功]\par\par
本章练习题\par\par答案分页：  [1] [2]\par\par
 \par\par第六章图 练习答案\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par3、解答： 无向图：\par\par算法思路：深度优先周游图，根据图中结点处于不同的连通分支来对它们进行不同的标记。周游结束后每个结点的标记值记录在数组value[]中，每个顶点v的标记值表示v属于第几个连通分支\par\parvoid Graph::Apart(){ //图的周游框架 int i,j;\par\parfor (i=0;i&lt;numVertex;i  )                  //对图的所有顶点的标志位进行初始化\par\parMark[i]=UNVISITED; for (i=0,j=1;i&lt;numVertex;i  ){\par\par/* 检查图的所有顶点是否被标记过，如果未被标记过，      则从该未被标记的顶点开始继续周游。*/\par\parif (Mark[i]==http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21UNVISITED) {     //查找新的连通分支。         do_traverse(i,j);         j  ;      } } }\par\parvoid Graph::do_traverse(int v,int mark) { //深度优先周游图     Mark[v]=VISITED;//标记顶点v的标志位\par\parvalue[v]=mark;//记录顶点v的标记值，表示v属于第mark个连通分支\par\par
//访问v邻接到的未被访问过的结点，并递归地按照深度优先的方式进行周游     for (Edge e=FirstEdge(v);IsEdge(e);e=NextEdge(e)) {         if (Mark[ToVertices(e)]==UNVISITED)             do_traverse(ToVertices(e),mark);      }  }   有向图：\par\par算法思路：从图中任取一个不属于任一连通分量的顶点u,再取另一个不属于任一连通分量的顶点v。然后判断u-&gt;v是否连通，v-&gt;u是否连通，如果两个都连通则u，v十强连通分量，并将u,v标记为属于同一连通分量。然后继续上述过程。 bool Graph::connected(int u,int v) { //判断u-&gt;v是否连通的函数     for (int i=0;i&lt;numVertex;i  )         Mark[i]=UNVISITED;     using std::queue;     queue&lt;int&gt;Q;     Q.push(u);//u入队列\par\parwhile (!Q.empty()){//用队列查找与u连通的所有结点中是否包括v         int temp=Q.front();         Q.pop();\par\parMark[temp]=VISITED;\par\parif (temp==v)// u-&gt;v连通，返回true             return true;\par\parfor (Edge e=Fhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21irstEdge(temp);IsEdge(e);e=NextEdge(e)) { //与temp相邻的所有未访问结点入队列\par\parif (Mark[ToVertex(e)]==UNVISITED)                 Q.push(ToVertex(e);         }       }\par\par
return false;//u-&gt;v不连通，返回false }\par\parvoid Graph::Apart() { //对图进行划分的函数，其中调用connected（）     memset(value,0,numVertex*sizeof(int));// 将每个结点的标记值初始化为0 int mark=0;\par\parfor (int i=0;i&lt;numVertex-1;i  ) {\par\parif (value[i]&gt;0)//结点i已经属于某个连通分量，则换下一个结点             continue;         mark  ;\par\parvalue[i]=mark;//结点i将生成第mark个连通分量         for (int j=i 1;j&lt;numVertex;j  ) {\par\parif (value[j]&gt;0)//结点j已经属于某个连通分量，则换下一个结点                 continue;\par\parif (connected(i,j)){ //结点i－&gt;j连通                if (connected(j,i))//结点j-&gt;i连通\par\parvalue[j]=mark;//i,j强连通，将j归于i生成的第mark个连通分量\par\par}//end if          }//end for       }//end for }\par\par4、解答：\par\par若该DAG是单向连通的（对任意两个顶点v1, v2，有v1可达v2或v2 可达v1），则具有唯一的拓扑序列。证明如下： 1）=&gt;\par\par若单向连通，对任意两个顶点v1, v2，它们在序列中的先后http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21次序是一定的。因此序列唯一。\par\par
2）&lt;=\par\par若序列唯一，用反证法证明单向连通。\par\par假设不是单向连通的，又因为双向连通不能产生唯一拓扑序列，则一定存在两个点v1, v2，它们相互不可达。则在排好的唯一的序列里，v1, v2中间的每个顶点一定只和v1, v2中一个点有单向的可达关系，因此可以划分成和v1有可达关系, 和v2有可达关系两组，显然这俩组的前后关系在图中是没有定义的。因此不唯一，假设不成立。\par\par5、解答：\par\par如果一个图存在权值为负数的边，那么，Dijkstra算法不可用。例如：\par\par \par\parV\par\par[此处图片未下载成功]\par\par
V2\par\parV1\par\par图6.10 带权有向图\par\par当源顶点是V0时，按照Dijkstra算法，顶点加入第一组的顺序是V0, V2, V1，D[0].length=0, D[0].pre=0  D[2].length=5, D[2].pre=0  D[1].length=6, D[1].pre=0\par\par但是，直观上， D[2].length=6-7＝-1, D[2].pre=1\par\par//改进后的算法，如果存在“负值环”则返回false，其它情况返回true bool ShortestPath(Graph&amp; G, int s, Dist* &amp;D) {        D=new Dist[G.VerticesNum()];\par\parint i, j;                              //i, j是计数器      //初始化Mark数组、D数组\par\parfor (i=0;i&lt;G.VerticesNum();  i) {\par\par且\par\par
D[i].length= INFINITY;               D[i].pre=s;        }\par\parD[s].length=0;\par\parfor (i=1;i&lt;G.VerticesNum();  i)   for (j=http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b210;j&lt;G.VerticesNum();  j)    if (D[j].length!=INFINITY)\par\parfor (Edge e=G.FirstEdge(j);G.IsEdge(e);e=G.NextEdge(e))                 if (D[G.ToVertex(e)].length&gt;(D[j].length G.Weight(e))) {\par\parD[G.ToVertex(e)].length=D[j].length G.Weight(e);\par\parD[G.ToVertex(e)].pre=j;                                             }\par\parfor (i=0;i&lt;G.VerticesNum();  i)  if (D[i].length!=INFINITY)\par\parfor (Edge e=G.FirstEdge(i);G.IsEdge(e);e=G.NextEdge(e))              if (D[G.ToVertex(e)].length&gt;(D[i].length G.Weight(e))) {         cout&lt;&lt;”存在负值环”;         return false;        }    return true;\par\par[此处图片未下载成功]\par\par
}\par\par本章练习题\par\par答案分页：\par\par \par\par第七章内排序 练习\par\par上一章 本章练习\par\par下一章\par\par[此处图片未下载成功]\par\par
 \par\par[1] [2]\par\par \par\par
1、在插入排序、快速排序、堆排序、归并排序中，排序方法不稳定的有_________。\par\par2、(教材习题7.9)考虑由3个不同记录组成的序列{A, B, C}，试分别画出表示下列排序算法的二叉判定树：直接插入排序，直接选择排序，冒泡排序。\par\par3、(教材习题7.13)如果一个整数序列中一半的数为http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21奇数，一半的数为偶数，编写一个算法，重新排列这些整数，使得所有的奇数位于奇数下标上，所有的偶数位于偶数下标上。（提示：参考快速排序的 分割算法）。\par\par4、(教材习题7.20)在堆排序中采用的堆是基于二叉树的，因此时间代价是O(nlogn) ，如果采用基于三叉树的堆来实现堆排序，时间代价会不会变成O(nlog3n)呢？试编写基于三叉树的堆排序算法，并分析时间代价。\par\par5、(教材习题7.24)教材中介绍的排序算法大都是基于数组实现的，大部分的算法也能用链表来实现，但有些特殊的算法不适合链式存储，你觉得哪些算法不适合链式存储？为什么？\par\par参考答案\par\par \par\par第七章内排序 练习答案\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par1、解答：          快速排序，堆排序\par\par2、解答：\par\par判定树其实就是一颗二叉树，可以用来模拟排序过程，每个结点代表了在某种限定条件下所有 可能的排列集合，特殊地，叶结点为只有一种可能的排列的结点，边代表了记录之间比较的一 个判断，一共有n!个叶结点。       直接插入排序的判定树如下：\par\par[此处图片未下载成功]\par\par
 \par\par
 \par\par直接选择排序的判定树如下：\par\par[此处图片未下载成功]\par\par
 \par\par冒泡排序的判定树如下：\par\par[此处图片未下载成功]\par\par
 \par\par3、解答：\par\par这个程序很像快速排序的前半部分，但是不包含分割算法那一部分。用两个变量even_i，odd_i， 分别遍历数组中下标为偶数和下标为奇数的数。当Array[even_i]为奇数，并且Array[odd_i]为偶 数时，交换；如此直到even_i或odd_i其中有一个不小于n为止。\par\parvoid sort（int Array[]） {  even_i = 0;  odd_i = 1;\par\par
}\par\par \par\parwhile (http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21odd_i &lt; n &amp;&amp; even_i &lt; n)  {  while (odd_i &lt; n &amp;&amp; a[odd_i] %2 == 1) odd_i =2;  while (even_i &lt; n &amp;&amp; a[even_i] %2 == 0) even_i =2;  if (odd_i &lt; n &amp;&amp; even_i &lt; n)   {   swap(a[odd_i],a[even_i]);   odd_i  = 2;   even_i  = 2;  } }\par\par4、解答：\par\par时间代价是O(nlog3n) 。不过，由于 表示法衡量的是算法的量级，所以 O(nlogn) 与O(nlog3n) 本质上是等价的。算法略，算法和基于二叉树的堆的算法类似，只是需要注意以下几点：\par\par（1）节点pos的三个子节点分别为3&#215;pos 1, 3&#215;pos 2和3&#215;pos 3&#215;，其父节点为(pos-1)/3。     （2）如果pos&gt;=CurrentSize/3 &amp;&amp; pos&lt;CurrentSize，则节点为叶节点。     （3）由于变成了三叉树，因此buildHeap和siftdown函数需要作相应改变。     （4）堆的其他函数以及堆排序算法不用变。\par\par&lt; 堆的其他函数以及堆排序算法不用变。     (4) 由于变成了三叉树，因此buildHeap和siftdown函数需要作相应改变。     (3)&gt;\par\par5、解答：\par\par（1）直接选择排序：由于这个排序方法是找出第i小的记录，并将这个记录放到数组中的第i个位置，而用链式存储，无法做到找到第i个位置，每个点的位置在一开始的时候是无法定位的。\par\par（2）shell排序：它是采用增量序列{2k,2k-1,…,2,1}，也就是说对每隔n个（n为增量序列的某个数）数字进行排序，这种方法过于依赖数据的位置，用链式存储，实在是很不方便。\par\par[此处图片未下载成功]\par\parhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21
 \par\par本章练习题\par\par \par\par第八章文件管理和外排序 练习\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题8.2）假定一个老磁盘配置如下：它的全部存储量将近675MB，分成15个盘面。每个盘面有612个磁道；每个磁道150个扇区；每个扇区512个字节；每个簇16个扇区。交错因子是4。磁盘旋转速度是3600rpm。I/O磁头的启动时间是3ms，磁头在两个相邻磁道间移动时间是0.08ms。根据习题8.1的结论，计算该\par\par
磁盘的平均寻道时间。\par\par2、（教材习题8.4）假定一个磁盘配置如下：存储总量将近1033MB，分成15个盘面。每个盘面有2100个磁道，每个磁道有64个扇区，每个扇区512字节，每个簇包括8个扇区。其交错因子是3，磁盘以7200rpm旋转。磁道转换时间是3ms，平均寻道时间是20ms。现在假定磁盘中有一个10MB的文件。假定文件中的第一个磁道随机位于磁盘上的某个位置，整个文件放在一组相邻磁道内，文件完全填满它所占据的磁道，读取文件中的所有数据要花多少时间？试给出计算过程。\par\par3、（教材习题8.9）假设原有一个计算机系统，能够处理一个大公司所有雇员记录的排序操作。由于公司合并，其雇员数目扩大为原来的100倍。计算机在可接受的时间内不能对原来100倍的记录进行外排序了。下面这几种独立的方案考虑对计算机系统进行升级，它们是否能够满足新的外排序要求？\par\par（1）CPU的速度增长两倍；\par\par（2）磁盘I/O时间缩短至原来的一半； （3）内存访问时间缩短至原来的一半； （4）内存大小增长两倍；\par\par4、（教材习题8.10）如果某个文件经内排序得到80个初始归并段，试问\par\par(1) 若使用多路归并执行3 趟完成排序，那么应取的归并路数至少应为多少？ (2) 如果操作系统要求一个程序同时可用的输入/输出文件的总数不超过15个，则按多路\par\par归并至少需要几趟可以完成排序？如果限定这个趟数，可取的最低路数是多少？\par\par5、（教材http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21习题8.12）教材中的算法8.5中我们实现了一种败者树的实现方法。我们还可以用另一种方法来初始化败者树：先构造一棵赢者树，然后把这棵赢者树映射成它所对应的败者树。这一种方法只需要修改败者树的两个成员函数Initialize和Play。其中Play用于在p处的比较，胜者索引放在B[p]中，若B[p]是右孩子则持续向上比赛；Initialize先按选手索引顺序调用Play，生成赢者树之后，再映射成败者树。请读者实现这种方法。\par\par参考答案\par\par \par\par第八章文件管理和外排序 练习答案\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par1、解答： 由8.1的结论，随机选取两个磁道的平均距离是磁道总数的1/3。每个盘面有612个磁道，则磁头的平均寻道时间为：        T=3 （612&#215;0.08）/3=19.32ms\par\par2、解答：\par\par每个簇为4KB：8个扇区＝512字节&#215;8＝4KB\par\par每个磁道有8个簇：64个扇区（注：除法符号前后不一致）8（扇区/簇）＝8簇\par\par
每转一圈的时间为：（60&#215;1000）ms7200圈＝8.3ms/圈 一个磁道的存储量为：64个扇区&#215;512字节＝32KB 文件占据的磁道数目：10MB/32KB＝313道 数据连续存放，所以：\par\par总存取时间＝平均寻道时间＋第一道读取时间＋（总磁道数－1）&#215;（第二次寻道时间＋读取整道的时间）\par\par＝20ms＋（3＋0.5）&#215;8.3ms＋312&#215;（3ms＋（0.5＋3）&#215;8.3ms） ＝10048.65ms\par\par3、解答：\par\par外排序的主要时间花销在于磁盘访问的I/O时间，内存中进行的内排序的时间可以在磁盘访问的同时进行，因此内排序的时间可以忽略不计。因此： （1）CPU的速度增长两倍并不能明显加快外排序的速度；\par\par（2）磁盘I/O时间缩短至原来的http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21一半可以将外排序速度提高一倍； （3）内存访问时间缩短至原来的一半并不能加快外排序的速度；\par\par（4）内存大小增长两倍虽然可以增加内排序的规模（变成原来的两倍），但是这也需要更多的数据来填充数据缓冲区，因此依然不能明显加快外排序的速度。\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第八章文件管理和外排序 练习答案\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par4、解答：\par\par（1）、设归并路数为k，k3≥80，由此解得k≥5，即应取的归并路数至少为5。 （2）、设多路归并的归并路数为k，需要k个输入缓冲区和1个输出缓冲区，k  1 = 15，因此k = 14，可做14路归并。由S= log1480  = 2，即至少需2趟归并可完成排序。\par\par若限定这个趟数，有80≤k2，可取的最低路数为9。  对于所谓“趟”的理解如下：\par\par
1 1\par\par1 1\par\par第一趟\par\par2 2\par\par第二趟\par\par4\par\par \par\par5、解答：\par\par【题意分析】\par\par1. 对于play()函数，只需将胜者索引存入B[p]中，并且不需要保存负者索引，即可以省略temp1与temp2.\par\par2．对于Initialize()函数，先将其初始化为胜者数，由于修改了play()，即调用原先的函数模式即可构建出来。\par\par3．将构造好的胜者树映射到败者树，先将B[0]赋以B[1]，而后从上往下，对于每一个B[p]，保存其左右子女的败者索引即可。\par\par4．根据B[p]下标p的不同位置，将B[ ]分为四种情况：         a. B[p]左右子女为外部结点，即B[2*p]与B[2*p 1]存在\par\parb. n为奇数，即有B[p]，其左右子女一为内部结点，一为外部结点\http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21par\parc. B[p]左右子女均为外部结点，且都位于最后一层，即下标从1到LowExt,         d. B[p]的左右子女均为外部结点，且都位于倒数第二层，即下标从LowExt到n\par\par【算法描述】\par\par//修改败者树的play template&lt; class T &gt;\par\parvoid LoserTree&lt;T&gt;::Play( int p, int lc, int rc, int(*winner)(T A[], int b, int c), int (*loser)(T A[], int b, int c) ) {\par\parB[p] = winner( L, lc, rc );     //胜者索引放在B[p]中\par\parwhile ( p &gt; 1 &amp;&amp; p%2 ) {    //当B[p]为右子女时，向父结点方向比较               B[p/2] = winner( L, B[p], B[p/2] ); //当前结点与其父结点的胜者放入父结点中\par\parp = p/2;        }\par\par//跳出循环后， p为1或B[p]为左子女，但B[0]未赋值 }\par\par//修改败者树的Initialize() template&lt; class T &gt;\par\parvoid LoserTree&lt;T&gt;::Initialize( T A[], int size, int (*winner)(T A[], int b,\par\par
int c), int (*loser)(T A[], int b, int c)) {\par\parif ( size&gt;MaxSize || size&lt;2 ) {       //若size值不恰当，直接返回               cout&lt;&lt;&quot;Bad Input!&quot;&lt;&lt;endl&lt;&lt;endl;               return;        }\par\par//初始化成员变量       http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21 n = size;         L = A;\par\parint i, s, pCount = 0;       //pCount表示数组B[]的最大下标        for ( s = 1; 2*s &lt; n - 1; s  = s );  //计算s=2log(n-1)        LowExt = 2 * (n-s);\par\paroffset = 2 * s - 1;                             //分别计算LowExt与offset\par\parfor ( i = 2; i &lt;= LowExt; i =2 )    //最底层外部结点的比赛               Play( (offset i)/2, i-1, i, winner, loser );\par\parif ( n%2 ) {                                //n为奇数，内部结点与外部结点比赛\par\parPlay( n/2, B[(n-1)/2], LowExt 1, winner, loser );               i = LowExt   3;        }\par\parelse\par\pari = LowExt   2;\par\parfor ( ; i &lt;= n; i =2)                     //处理剩余外部结点               Play( (i-LowExt n-1)/2, i - 1, i, winner, loser );        //以上为构建胜者树，以下为从胜者数映射到相应的败者树        B[0] = B[1];                        //将B[0]赋以B[1]，即此时的最大胜者\par\parpCount = offset - n   LowExt;  //计算出pCount值        //分别处理四类不同的B[i]值\par\par//第一类B[i]值，其左右子女均为内部结点        for ( i = 1; i &lt;= (PCount-1)/2; http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21i   )\par\parB[i] = loser( L, B[2*i], B[2*i 1] ); //直接存储其左右子女的败者索引\par\par//如果n为奇数，有第二类B[i]值，其左右子女一为内部结点，一为外部结点\par\parif ( n%2 ) {//此时的外部结点下标为LowExt 1\par\parB[n/2] = loser( L, B[(n-1)/2], LowExt 1 );        }\par\par//处理第三类B[i]值，其左右子女为外部结点且都位于最后一层        for ( i = 2; i &lt;= LowExt; i =2 )\par\parB[(i offset)/2] = loser( L, i-1, i );        if ( n%2 )\par\pari = LowExt   3;     else\par\par
i = LowExt   2;\par\par//处理第四类结点，其左右子女均为外部结点且都位于倒数第二层        for ( ; i &lt;= n; i  = 2)\par\parB[ (i-LowExt n-1)/2 ] = loser( L, i-1, i );\par\par[此处图片未下载成功]\par\par
}\par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第九章检索 练习\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题9.3）考虑用双向链表来实现一个有序表，使得能在这个表中进行正向和反向检索。若指针p总是指向最后成功检索到的结点，检索可以从p指示的结点出发沿任一方向进行。\par\par(1) 根据这种情况编写一个函数search(head，p，key)，检索具有关键码key的结点，并相应地修改p。  (2) 假设有序表中元素个数为n，请给出检索成功和检索不成功时的平均检索长度。\par\par2、（教材习题9.5）设有n个运动员要进行网球循环赛。用分治法设计一个满足以下要求的http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21比赛日程表：  (1) 每个选手必须与其他n-1各选手各赛一次；  (2) 每个选手一天只能赛一次；\par\par当n是偶数时，循环赛进行n-1天；当n是奇数时，循环赛进行n天。\par\par3、（教材习题9.8）假设我们讨论的集合是全集合{ 0, 1, 2, 3, …, n }的一个子集合，且n是一个不大的整数。请定义出该集合的抽象数据类型，并使用集合抽象数据类型中的基本操作，编写打印一个有穷集合中的所有成员的算法。\par\par4、（教材习题9.16）设散列表为HT[13]，散列函数为h(key)=key。用闭散列法解决冲突，对下列关键码序列12, 23, 45, 57, 20, 03, 78, 31, 15, 36造表。\par\par(1) 采用线性探查法寻找下一个空位，画出相应的散列表，并计算等概率下成功检索的平均检索长度和不成功检索的平均长度。\par\par(2) 采用双散列法寻找下一个空位，散列函数为rh(key)=(7?key) 1, 寻找下一个空位的公式为hi=(hi-1 rh(key), h1=h(key)。画出相应的散列表，并计算等概率下成功检索的平均检索长度。\par\par5、（教材习题9.19）有一个7个槽的散列表(槽从0到6编号)，使用散列函数h(k) = k mod 7和线性探查，依次插入3、12、9、2。  (1) 显示最后的结果散列表。\par\par(2) 在插入值2的关键码之后，每一个空槽作为下一个被填充槽的概率是多少？\par\par参考答案\par\par \par\par第九章检索 练习答案 上一章   下一章\par\par
[此处图片未下载成功]\par\par
本章练习题\par\par答案分页：  [1] [2]\par\par1、解答： 【题意解析】\par\par由于双向链表是有序的，将关键码与指针p指向的值比较，     如果大于p指向的值，则向右顺序搜索，小于则向左顺序搜索。 【典型错误】\par\par采用递归调用，p指针的修改不能正常进行\par\par程序中间的if else语句两分支都有返回语句，导致程序截止\par\par在循环中，比较p指针和key的值，小则指针http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21右移，大则指针左移，可能出现死循环\par\par【算法描述】 //双向有序表\par\parbool search(LinkNode* head, LinkNode* &amp;p, int key) {  if(head == NULL) return false;  if(p == NULL) p = head;  linkNode* temp = p;   while(temp-&gt;getKey()&lt; key &amp;&amp; temp-&gt;next())//右寻   temp=temp-&gt;next();  while(temp-&gt;getKey()&gt; key &amp;&amp; temp-&gt;prev())//左寻   temp=temp-&gt;prev();   if(temp-&gt;value == key) {//找到   p=temp;   return true;   }  else return false;                            }\par\par假设p指向任意位置的概率是平均的,key在任意位置的概率也是平均的。 成功检索的平均检索长度：\par\par- 最好情况为p指向中间，从链首开始各位置的检索长度为   n/2,n/2-1,...,1,2,3,...,n-n/2 1，平均值为n/4\par\par- 最差情况为p指向链首(或尾)，从链首开始各位置的检索长度为   1,2,...,n，平均值为n/2\par\par- 平均情况需要计算p在各种情况下的平均值，相当于求如下数字的平均值 1 2 3 4   n 2 1 2 3   n-1             N n-1 n-2 n-3   1\par\par数字排列成n&#215;n的矩阵，其求和公式为n&#215;(n 1)&#215;(n 2)/3-n，除以n&#215;n，平均值为n/3\par\par不成功检索的关键码可能位置为n 1处，其平均检索长度分析如下：\par\par
- 最好情况为p指向中间，从链首前的位置开始各位置的检索长度为   n/2,n/2,n/2-1,...,3,2http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21,2,3,...,n-n/2 1,n-n/2 1，平均值为n/4 1 - 最差情况为p指向链首(或尾)，从链首前的位置开始各位置的检索长度为   1, 2, ..., n, n ，平均值为n/2 1\par\par- 平均情况类似于成功检索时的求法，只是矩阵变成n&#215;(n 1)了，平均值为n/3 1\par\par \par\par2、解答：  【题意解析】\par\par本题考察利用分治法解决问题的能力，分治法的思想是对一个大问题分解成若干个类似的小问题，对每个小问题继续分解，直至分解到能用简单的方法解决这个小问题。然后把分解后的结果综合起来构成大问题的解。主要有三个过程，分解，求解，综合。  【典型错误】\par\par错误一般发生在不知对什么分解，不知如何分解，综合求解是不知如何综合。本题是对选手数分解，采取平分分解，综合求解时利用组内解答加上组间解答即可。  【数据结构】      采用线性表。\par\par【算法描述】\par\par//n表示待安排赛程的人数 //s表示待安排赛程的队员集\par\par//pairs[i]是一个链表指针，用来记录第i天的对阵情况, //则pairs[1],..., pairs[n]记录了整个赛程 void schedule(int n, Set s, Link *pairs)  {\par\parif(n%2==1)\par\par{             //奇数个队员，补一个空队员     s = s U {empty};\par\parschedule(n 1, s, pairs);   }   else\par\par{                  //偶数个队员     if(n==2)\par\par{           //若只有两个队员，安排这两个队员比赛，然后返回       pairs[1]-&gt;add(a,b);       return;     }\par\par//如果多于2人，分而治之\par\par/*s分成两个各含n/2个队员的集合s1, s2，                       然后在各自队员集合范围内安排前n/2天的赛程*/     shttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21chedule(n/2, s1, pairs);     schedule(n/2, s2, pairs);\par\par
//合并                     //设两s1, s2中的选手分别为A[1],..., A[n/2]; B[1],..., B[n/2]\par\parif( (n/2)%2 == 0)      {\par\par/*前面n/2-1天的比赛情况已经安排好，                     并分别存在链表pairs[1]到pairs[n/2-1]中                     下面安排第n/2-1天后的比赛(共n/2天)*/      for(int x=1; x&lt;=n/2; x  )                   //第n/2-1 x天比赛情况\par\par/*选手A[i]与选手B[(i x-1)%(n/2)]比赛，                    并将比赛对阵情况加入链表pairs[n/2-1 x]中*/        pairs[n/2-1 x]-&gt;add( A[i], B[(i x-1)%(n/2)] )     }\par\parelse      {\par\par/*由于n/2为奇数，因此，在前n/2天的比赛中，                   s1和s2中进行的比赛每天都恰有一个人轮空,                   为此，需要调整赛程如下*/       for(int i=1; i&lt;=n/2; i  )        {\par\par//第i天s1中轮空的队员A[m]和s2中轮空的队员B[n]比赛         pairs[i]-&gt;remove(A[m], empty);         pairs[i]-&gt;remove(B[n], empty);         pairs[i]-&gt;add(A[m], B[n]);       }\par\par/*前面n/2天的赛程已经安排好，\par\par并分别存在链表pairs[1]到pairs[n/2]中                   在上面步骤中，安排轮空http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21的队员参加比赛，使前n/2天最终没有人轮空,\par\par记这样的安排中A[i]的对手为C[i] (i=1,.., n/2)，则C[1],..., C[n/2]为\par\parB[1], ..., B[n/2]的一个排列。*/\par\par/*下面安排第n/2天后的比赛(共n/2-1天)\par\par(对阵情况A[i]对C[i]在前面已经安排了，因此少了一天)*/       for(int x=1; xadd( A[i], C[(i x)%(n/2)] )       }     }   } }\par\par
本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第九章检索 练习答案\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par3、解答： 【题意解析】\par\par因为n是一个不大的整数，可以扫描一定范围内的整数，如果该数在集合中，则打印。\par\par那么就要求集合必须有判断元素是否在集合中的操作。 【算法描述】 template   class Set {  Set(T item);  ~Set();  bool contains(T item);//判断集合是否包含指定item  ... }\par\parvoid print(Set s) {  for(int i=0; i&lt;= n; i  )    if(s.contains(i))    cout &lt;&lt; i &lt;&lt; &quot; &quot;; }\par\par4、解答：\par\par
[此处图片未下载成功]\par\par
 \par\par采用线性探查法的方法，31的检索长度为4，36的检索长度为2，其余数字的检索长度为1。因此，成功时平均检索长度是：8&#215;1/10 4&#215;1/10 2&#215;1/10=1.4。\par\par根据上面的散列表，如果关键码的散列值为0并且关键码不在散列表中，必须要探查到散列表的位置1，其检索长度为2。依此类推，采用双散http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21列法，不成功时的检索品均长度是：(2 1 3 2 1 5 4 3 2 1 5 4 3)/13=36/13  31的检索长度为2，36的检索长度为2，其余数字的检索长度为1。因此，  成功的平均检索长度是：8&#215;1/10 2&#215;1/10 2&#215;1/10=1.2\par\par5、解答：  (1)\par\par[此处图片未下载成功]\par\par
 \par\par(2) 插入值2的关键码后，如果h(k)=0，填充槽0；h(k)=1，填充槽1；h(k)=2-6，填充槽6。假设h(k)为0-6的概率是相同的，那么空槽作为下一个被填充槽的概率分别是： p(slot0) = 1/7，p(slot1) = 1/7，p(slot6) = 5/7。\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第十章索引技术 练习\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题10.2）假定一个计算机系统有4 096字节的磁盘块。要存储的每一条记录中4个字节是关键码，64个字节是数据字段。记录已经排序，顺序地存储在磁盘文件中。每个块中地第一条记录是用于线性索引。通过线性索引访问磁盘文件中的记录。如果线性索引的大小是2MB。最多可以在磁盘文件中存储多少条记录？ (2) 如果线性索引也存储在磁盘中（这样它的大小仅受二级索引的限制），而且使用如图10.2所示的4 096个字节（即1 024个关键码）的二级索引时，文件中最多可以存储多少条记录？（二级索引中的每个单元引用线性索\par\par
引的磁盘块中最小的关键码值。）\par\par2、(北大计算机专业2000年考研题)设有3阶B树如下图所示，分别画出从下图所示B树中插入关键码20后和从下图所示B树中删除关键码150后得到的两棵B树。\par\par[此处图片未下载成功]\par\par
 \par\par3、(北大计算机专业1999年考研题)下为一棵3阶B 树      1) 画出插入关键http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21码15后的B 树。\par\par2) 画出在原图(不是插入关键码15后的图)删除关键码75后的B 树。\par\par[此处图片未下载成功]\par\par
 \par\par参考答案\par\par \par\par第十章索引技术 练习答案\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par1、解答：\par\par每个磁盘块有4096个字节，一条记录的存储空间为4 64=68个字节，因此每个磁盘块能存储记录60条。  (1) 索引存储在内存中，2M字节，由于关键码加指针为8个字节，因此索引项为2M / 8 =256 K条。按照题意，每个块中的第一条记录用于线性索引，故可以索引218个磁盘块。存储的记录数为256K&#215;60=15&#215;220=15M。  (2) 二级索引的索引项有4096个字节/8字节=512个，即可以索引512个线性索引。每个线性索引又可以索引512个磁盘块。故存储记录数为512&#215;512&#215;60=15M。\par\par2、解答：\par\par
（1）原图中插入关键码20后：\par\par[此处图片未下载成功]\par\par
 \par\par（2）原图中删除关键码150后：\par\par[此处图片未下载成功]\par\par
 \par\par3、解答：（1）插入关键码15后的B 树。\par\par[此处图片未下载成功]\par\par
 \par\par（2）原图(不是插入关键码15后的图)删除关键码75后的B 树。\par\par
[此处图片未下载成功]\par\par
 \par\par本章练习\par\par \par\par第十一章高级线性结构 练习\par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题11.1）设计一个算法，将按行优先原则顺序存储的二维数组Ann转置(aij与aji交换)，要求转置结果仍占用原来的存储空间。\par\par2、（教材习题11.3）若在m&#215;n的矩阵http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21中存在―个元素A[i，j]满足：A[i，j]是第i行元素中最小值，且是第j列元素中最大值，则称矩阵A有鞍点。试写一个算法，找出矩阵A的一个鞍点，若A中不存在鞍点，则给出某种信息(采用行优先原则顺序存储矩阵Amn)。\par\par3、（教材习题11.7）二进制地址为101100100000块，若其大小分别为4、8、16或32字节，它的伙伴地址是多少？\par\par4、组织成循环链表的可利用空间表附加什么条件时，首次适配策略就转变为最佳适配策略？  参考答案\par\par \par\par第十一章高级线性结构 练习答案\par\par \par\par上一章   下一章\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par1、解答： 【算法描述】\par\par设二维数组Ann是整数类型的数组，则可以利用一个循环将矩阵对角线以上的元素与对角线以下的元素 交换。\par\parint A[n][n];\par\parint temp;     //用于交换的临时变量 for(int i=0;i&lt;n;i  )\par\par
for(int j=i 1;j&lt;n;j  )        {\par\partemp=A[i][j];               A[i][j]=A[j][i];               A[j][i]=temp;           }\par\par2、解答：      【算法描述】\par\par找出鞍点的算法如下：先找出每一行中具有最小值的那个元素，再判断该元素在它所在的列中是否是最大值。如果是，那么这个元素是一个鞍点，程序可以结束了。如果最终没有找到一个鞍点，则打印出相关信息。算法复杂度为O(m*n)。如下的伪码假设A矩阵为整数类型。 int A[m][n]; int i,j;\par\parfor(i=0;i&lt;m;i  ){   int min=INT_MAX;\par\parint col_min; //记录具有最小值的元素的列数\par\par//找出第i行最小值的元素,并将其列数记录在col_mihttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21n中.   for(j=0;j&lt;n;j  )     if(A[i][j]&lt;min){       min=A[i][j];       col_min=j;     }\par\par//判断该元素是否为所在列的最大值   bool isMax=true;   for(j=0;j&lt;n;j  ){\par\parif(A[j][col_min]&gt;A[i][col_min])       isMax=false;   }   if(isMax){\par\parcout&lt;&lt;”矩阵存在鞍点，一个鞍点是第”&lt;&lt;i&lt;&lt;”行，第”&lt;&lt;j&lt;&lt;”列的元素”&lt;&lt;endl;     exit(0);   } }\par\par//如果没有找到鞍点，打印出相关的信息 cout&lt;&lt;”矩阵不存在鞍点”&lt;&lt;endl;\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第十一章高级线性结构 练习答案\par\par上一章   下一章\par\par \par\par
[此处图片未下载成功]\par\par
本章练习题\par\par答案分页：  [1] [2]\par\par3、解答：\par\par(1)     块大小为4字节，伙伴地址为101100100100     (2)     块大小为8字节，伙伴地址为101100101000     (3)     块大小为16字节，伙伴地址为101100110000     (4)     块大小为32字节，伙伴地址为101100000000\par\par4、解答：\par\par组织成循环链表的可利用空间表的结点大小按递增序排列时, 首次适配策略就转变为最佳适配策略。\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par第十二章高级树结构 练习\par\par上一章   下一章\parhttp://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21\par[此处图片未下载成功]\par\par
 \par\par本章练习\par\par1、（教材习题12.2）对于下面一组值{cpu,cop,copy.hit,hi,his,hia,he},给出他们的PATTrie结构。  2、（教材习题12.6）从空的二叉树开始，根据字典顺序，（注意：”he”&lt;”tea”&lt;”teacher”），         严格按照AVL树插入算法，依次插入依次插入{head、he、tea、teach、twin、hot、toss}。请画         出插入后的AVL树。\par\par3、（教材习题12.13）教材习题12.13）一个给定序列的子序列是在该序列中删去若干元素后得到的         序列。确切地说， 若给定序列X={x1,x2,...,xm},则另一序列Z={z1,z2,...,zk}是X的子序列是         指存在一个严格递增的下标序列{i1,i2,...,ik}使得对于所有j=1,2,...k有zj=xi。例如，序列         Z={B,C,D,B}是序列X={A,B,C,B,D,A,B}的子序列，相应的递增下标序列是{2,3,5,7}。 给定两个\par\par序列X和Y，若序Z既是X的子序列又是Y的子序列时，称Z是序列X和序列Y的公共子序列(common          subsequence)。 例如，若X={A,B,C,B,D,A,B}，Y={B,D,C,A,B,A},则序列Z={B,C,A}是序列X和         序列Y的一个公共子序列。同样，{B,C,B,A}也是X序列和Y序列的一个公共子序列。并且，序列         X和序列Y没有长度大于4的其它公共子序列，因此，序列{B,C,B,A}是序列X和序列Y的一个最长公         共子序列(LCS)。 给定两个序列X={x1,x2,...,xm}和Y={y1,y2,...yn},请用动态规划法找出X和         Y的一个最长公共子序列。\par\par4、（教材习题12.14）将教材图12.32的PR四分树转化为k-d树，这些点按照字母顺序插入。\par\par
[此处图片未下载成功]\par\http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21par
 \par\par5、（教材习题12.27）对于教材图12.26所示的假想两人游戏的博弈树，要求： 1）按教材算法12.7的求值次序列出博弈树的所有结点\par\par2）用教材算法12.8求各结点的过程中，那些结点的值不会被计算。\par\par[此处图片未下载成功]\par\par
参考答案\par\par \par\par第十二章高级树结构 练习答案\par\par上一章     本章练习题\par\par答案分页：  [1] [2]\par\par、解答：\par\par下一章\par\par[此处图片未下载成功]\par\par
 \par\par（       （\par\par \par\par1\par\par
[此处图片未下载成功]\par\par
 \par\par2、解答：\par\par[此处图片未下载成功]\par\par
 \par\par3、解答：\par\par \par\par考虑最长公共子序列问题如何分解称子问题，设X={x1,x2, ,xm}, Y = {y1,y2, ,yn}，并Z=\par\par{z1,z2, ,zk}为他们的最长公共子序列。不难证明下列性质\par\par（1）       如果xm = yn, 则zk = xm = yn,且”z1,z2, ,zk-1”是” x1,x2, ,xm-1”和” y1,y2, ,yn-1”的 个最长公共子序列。\par\par（2）       如果xm ！= yn, 则若zk ！= xm,蕴涵”z1,z2, ,zk”是” x1,x2, ,xm-1”和” y1,y2, ,yn”的一   个最长公共子序列。 （3）       如果xm ！= yn, 则若zk ！= yn,蕴涵”z1,z2, ,zk”是” x1,x2, ,xm”和” y1,y2, ,yn-1”的一  个最长公共子序列。\par\par这样，令c[i][j]为序列Xi与Yj的最长公共子序列的长度。则有如下的规划方程：\par\par
[此处图片未下载成功]\par\par
 \par\parint lcs_len(char *x char *y, int c[ ][ ])   http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21  {\par\parint m=strlen(x), n=strlen(y), i,j;        //初始化\par\parfor (i=0;i&lt;=m;i  ) c[i][0]=0;        for (i=0;i&lt;=n;i  ) c[0][i]=0;        //通过两层循环求c[i][j];        for (i=1;i&lt;=m;i  )           for (j=1;j&lt;=m;j  )\par\parif (x[i-1]==y[j-1]) c[i][j]=c[i-1][j-1] 1;           else c[i][j] = MAX(c[i][j-1], c[i-1][j];         return c[m][n];     }\par\par//利用上面的函数，获取最长公共子序列，存于s中。     void build_lcs(char s[ ],char *x, char *y)   { int k, i=strlen(a), j=strlen(b);     k=lcs_len(x,y,c); //LCS长度     s[k]=’\0’;     while (k&gt;0)\par\parif (c[i][j]==c[i-1][j]) i--;     else if (c[i][j]==c[i][j-1]) j--;     else {      s[--k]=x[i-1];     i--; j--;     }  }\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par \par\par第十二章高级树结构 练习答案 答案分页：上一章下一章\par\par[1] [2]\par\par \par\par
[此处图片未下载成功]\par\par
本章练习题\par\par答案分页：  [1] [2]\par\par \par\par4、解答：\par\par[此处图片未下载成功]\par\par
 \par\par5、解答：\par\par（1）算法12.7按照后跟次序求各个结点的值，因此先从左至右求第4层的结点http://www.mianfeiwendang.com/doc/001efab5df8ad5ccdd9d1b21的值，然后依次求第 3、2、1层的结点的值，所得的结点次序如下 第四层从左至右：P31，P32，P33，P34，P35，P36，P37，P38，P39，P310，P311， P312，P313，P314 第三层从左至右：P21，P22，P23，P24，P25，P26，P27，P28 第二层从左至右：P11，P12，P13，P14 根结点： P01\par\par（2）根据算法12.8，进行α－β裁减 上图中，一旦P27的值确定为5，P14的β成为5，V（P313）大于P14的β值，从而确定了P28的值大 于P14的值，就意味着不必产生P314了。同理，一旦P13的值确定为10，P14的α成为10，当算出P27 的值为5，小于P01的α值，从而确定了P14的值小于P01的值，就意味着不必产生P28了。 综上：以结点P14为根的子树都不用产生\par\par[此处图片未下载成功]\par\par
 \par\par本章练习题\par\par答案分页：  [1] [2]\par\par \par\par
 \par\par
}{
\rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\loch\af13\insrsid6493368\charrsid15866361 
\par }\pard \ltrpar\qj \li0\ri0\sl180\slmult0\nowidctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid6493368 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6493368 
\par 
\par 
\par 
\par 
\par }{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\insrsid15817367\charrsid15817367 \loch\af13\hich\af13\dbch\f13 \'ce\'c4}{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\insrsid11941893 \loch\af13\hich\af13\dbch\f13 \'b5\'b5}{\rtlch\fcs1 \af0\afs28 
\ltrch\fcs0 \f13\fs28\insrsid15817367\charrsid15817367 \loch\af13\hich\af13\dbch\f13 \'cf\'c2\'d4\'d8\'cd\'f8\'ca\'c7\'d7\'a8\'d2\'b5\'b5\'c4\'c3\'e2\'b7\'d1\'ce\'c4\'b5\'b5\'cb\'d1\'cb\'f7\'d3\'eb\'cf\'c2\'d4\'d8\'cd\'f8\'d5\'be\'a3\'ac\'cc\'e1\'b9\'a9
\'d0\'d0\'d2\'b5\'d7\'ca\'c1\'cf\'a3\'ac\'bf\'bc\'ca\'d4\'d7\'ca\'c1\'cf\'a3\'ac\'bd\'cc\'d1\'a7\'bf\'ce\'bc\'fe\'a3\'ac\'d1\'a7\'ca\'f5\'c2\'db\'ce\'c4\'a3\'ac\'bc\'bc\'ca\'f5\'d7\'ca\'c1\'cf\'a3\'ac\'d1\'d0\'be\'bf\'b1\'a8\'b8\'e6\'a3\'ac\'b9\'a4
\'d7\'f7\'b7\'b6\'ce\'c4\'a3\'ac\'d7\'ca\'b8\'f1\'bf\'bc\'ca\'d4\'a3\'ac}{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\insrsid15817367\charrsid15817367 \hich\af13\dbch\af13\loch\f13 word}{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 
\f13\fs28\insrsid15817367\charrsid15817367 \loch\af13\hich\af13\dbch\f13 \'ce\'c4\'b5\'b5\'a3\'ac\'d7\'a8\'d2\'b5\'ce\'c4\'cf\'d7\'a3\'ac\'d3\'a6\'d3\'c3\'ce\'c4\'ca\'e9\'a3\'ac\'d0\'d0\'d2\'b5\'c2\'db\'ce\'c4\'b5\'c8\'ce\'c4\'b5\'b5\'cb\'d1\'cb\'f7
\'d3\'eb\'ce\'c4\'b5\'b5\'cf\'c2\'d4\'d8\'a3\'ac\'ca\'c7\'c4\'fa\'ce\'c4\'b5\'b5\'d0\'b4\'d7\'f7\'ba\'cd\'b2\'e9\'d5\'d2\'b2\'ce\loch\af13\hich\af13\dbch\f13 \'bf\'bc\'d7\'ca\'c1\'cf\'b5\'c4\'b1\'d8\'b1\'b8\'cd\'f8\'d5\'be\'a1\'a3}{\rtlch\fcs1 \af0\afs28 
\ltrch\fcs0 \fs28\loch\af13\insrsid15817367 
\par }{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\cf11\insrsid11941893 \loch\af13\hich\af13\dbch\f13 \'ce\'c4\'b5\'b5}{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\cf11\insrsid6493368\charrsid6493368 \loch\af13\hich\af13\dbch\f13 \'cf\'c2\'d4\'d8}{
\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\cf11\insrsid6493368\charrsid6493368 \hich\af13\dbch\af13\loch\f13  }{\field{\*\fldinst {\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\cf11\insrsid11941893 \hich\af13\dbch\af13\loch\f13  HYPERLINK "}{\rtlch\fcs1 
\af0\afs28 \ltrch\fcs0 \f13\fs28\cf11\insrsid11941893\charrsid11941893 \hich\af13\dbch\af13\loch\f13 http://www.mianfeiwendang.com/}{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\cf11\insrsid11941893 \hich\af13\dbch\af13\loch\f13 " }{\rtlch\fcs1 \af0\afs28 
\ltrch\fcs0 \fs28\cf11\loch\af13\insrsid8944438\charrsid13773176 {\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b02000000170000001e00000068007400740070003a002f002f007700770077002e00770065006e00640061006e0067007800690061007a00610069002e0063006f006d002f000000e0c9ea79f9bace118c8200aa004ba90b5400000068007400740070003a002f002f0077007700
77002e00770065006e00640061006e0067007800690061007a00610069002e0063006f006d002f000000795881f43b1d7f48af2c825dc485276300000000a5ab000000000000}}}{\fldrslt {\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \cs17\f13\fs28\ul\cf2\insrsid11941893\charrsid13773176 
\hich\af13\dbch\af13\loch\f13 http://www.mianfeiwendang.com/}}}\sectd \linex0\headery851\footery992\colsx425\endnhere\sectlinegrid312\sectspecifyl\sectrsid6493368\sftnbj {\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 
\fs28\cf11\loch\af13\insrsid6493368\charrsid6493368 
\par }{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\cf11\insrsid11941893 \loch\af13\hich\af13\dbch\f13 \'d2\'da\'cd\'f2}{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \f13\fs28\cf11\insrsid6493368\charrsid6493368 \loch\af13\hich\af13\dbch\f13 \'ce\'c4\'b5\'b5\'d7\'ca
\'c1\'cf\'a3\'ac\'b5\'c8\'c4\'e3\'c0\'b4\'b7\'a2\'cf\'d6}{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \fs28\cf11\loch\af13\insrsid15098623\charrsid6493368 
\par }}